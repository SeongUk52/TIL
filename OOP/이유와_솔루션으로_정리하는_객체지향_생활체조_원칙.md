# 이유와 솔루션으로 정리하는 객체지향 생활체조 원칙

[원글](https://hudi.blog/thoughtworks-anthology-object-calisthenics/)

### 7가지 코드 품질 항목
- 응집도(cohesion)
- 느슨한 결합(loose coupling)
- 무중복(zero duplication)
- 캡슐화(encapsulation)
- 테스트 가능성(testability)
- 가독성(readability)
- 초점(focus)

[소트웍스 앤솔러지 원문](https://developerfarm.wordpress.com/2012/01/26/object_calisthenics_1/)


## 객체지향 생활체조 원칙
1. [한 메서드에 오직 한 단계의 들여쓰기만 한다.](#1-한-메서드에-오직-한-단계의-들여쓰기만-한다)
2. [else 예약어(keyword)를 쓰지 않는다.](#2-else-예약어keyword를-쓰지-않는다)
3. 모든 원시값과 문자열을 포장(wrap)한다.
4. 한 줄에 점을 하나만 찍는다.
5. 줄여쓰지 않는다(축약 금지).
6. 모든 엔티티(entity)를 작게 유지한다.
7. 2개 이상의 인스턴스 변수를 가진 클래스를 쓰지 않는다.
8. 제일 클래스(first-class) 콜렉션을 쓴다.
9. 게터(getter)/세터(setter)/프로퍼티(property)를 쓰지 않는다.


### 1. 한 메서드에 오직 한 단계의 들여쓰기만 한다.

#### why?
```java
class Board {
//    ...
   String board() {
      StringBuffer buf = new StringBuffer();
      for (int i = 0; i < 10; i++) {
         for (int j = 0; j < 10; j++)
            buf.append(data[i][j]);
         buf.append("\n");
      }
      return buf.toString();
   }
}
```
코드의 들여쓰기 깊이가 깊어질 수록 가독성이 하락한다. 너무 긴 함수 읽고 파악하기 힘들다.
또한 함수에 많은 중첩구조가 생겼다는 것은 함수가 하는 일이 많다는 것이다.

```
"함수는 한 가지를 해야 한다. 그 한 가지를 잘 해야 한다. 그 한 가지만을 해야 한다." ― 클린코드
```

#### solution
이런 함수의 구조를 개선하기 위해 [메소드 추출(Extract Method) 기법](https://refactoring.com/catalog/extractFunction.html)
을 사용할 수 있다. 메소드 추출은 코드의 일부분을 메소드로 분리하여, 코드의 복잡도를 낮추는 기법이다.

```java
class Board {
   // ...
   String board() {
      StringBuffer buf = new StringBuffer();
      collectRows(buf);
      return buf.toString();
   }

   void collectRows(StringBuffer buf) {
      for (int i = 0; i < 10; i++)
         collectRow(buf, i);
   }

   void collectRow(StringBuffer buf, int row) {
      for (int i = 0; i < 10; i++)
         buf.append(data[row][i]);
      buf.append("\n");
   }
}
```

### 2. else 예약어(keyword)를 쓰지 않는다.
#### why?
#### solution


### 3. 모든 원시값과 문자열을 포장(wrap)한다.
#### why?
#### solution


### 4. 한 줄에 점을 하나만 찍는다.
#### why?
#### solution


### 5. 줄여쓰지 않는다(축약 금지).
#### why?
#### solution


### 6. 모든 엔티티(entity)를 작게 유지한다.
#### why?
#### solution


### 7. 2개 이상의 인스턴스 변수를 가진 클래스를 쓰지 않는다.
#### why?
#### solution


### 8. 제일 클래스(first-class) 콜렉션을 쓴다.
#### why?
#### solution


### 9. 게터(getter)/세터(setter)/프로퍼티(property)를 쓰지 않는다.
#### why?
#### solution