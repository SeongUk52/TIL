# 함수

의도를 분명히 표현하는 함수를 어떻게 구현할 수 있을까? 함수에 어떤 속성을 부여해야 처음 읽는 사람이 프로그램 내부를 직관적으로
파악할 수 있을까?

## 작게 만들어라!

- 함수는 100줄을 넘어서는 안 된다. 20줄도 길다.

### 블록과 들여쓰기
- if문/ else문/ while문 등에 들어가는 블록은 한 줄이어야 한다.
  - 그러면 바깥을 감싸는 함수가 작아질 뿐 아니라, 블록 안에서 호출하는 함수 이름을 적절히 짓는다면, 코드를 이해하기도 쉬워진다.
- 이 말은 중첩 구조가 생길만큼 함수가 커져서는 안 된다는 뜻이다.
  - 그러므로 함수에서 들여쓰기 수준은 1단이나 2단을 넘어서면 안 된다.
    - 그래야 함수는 읽고 이해하기 쉬워진다.

## 한 가지만 해라!
- "함수는 한 가지를 해야 한다. 그 한 가지를 잘 해야 한다. 그 한 가지만을 해야 한다."
- 단순히 다른 표현이 아니라 의미 있는 이름으로 다른 함수를 추출할 수 있다면 그 함수는 여러 작업을 하는 셈이다.

### 함수 내 섹션
- 한 가지 작업만 하는 함수는 자연스럽게 섹션으로 나누기 어렵다.

## 함수당 추상화 수준은 하나로
- 함수가 확실히 '한 가지'작업만 하려면 함수 내 모든 문장의 추상화 수준이 동일해야 한다.
  - 한 함수 내에서 추상화 수준을 섞으면 코드를 읽는 사람이 헷갈린다.
  - 특정 표현이 근본 개념인지 아니면 세부사항인지 구분하기 어려운 탓

### 위에서 아래로 코드 읽기: "내려가기" 규칙
- 코드는 위에서 아래로 이야기처럼 읽혀야 좋다.
  - 한 함수 다음에는 추상화 수준이 한 단계 낮은 함수가 온다.


## Switch 문
- 다형적 객체를 생성하는 인스턴스 코드에서만 사용하고 상속 관계로 숨긴 후 절대로 다른 코드에 노출하지 않는다.
- 가급적 사용 자제
- 불가피한 상황도 있다.

## 서술적인 이름을 사용하라!
- 코드를 읽으면서 짐작했던 기능을 각 루틴이 그대로 수행한다면 깨끗한 코드
- 함수가 작고 단순할수록 서술적인 이름을 고르기도 쉬워진다.
- 이름이 길어도 괜찮다. 길고 서술적인 이름이 짧고 어려운 이름보다 좋다.
- 길고 서술적인 이름이 길고 서술적인 주석보다 좋다.
- 함수 이름을 정할 때는 여러 단어가 쉽게 읽히는 명명법을 사용한다.
- 서술적인 이름을 사용하면 개발자 머릿속에서도 설계가 뚜렷해지므로 코드를 개선하기 쉬워진다.


- 이름을 붙일 때는 일관성이 있어야 한다.
  - 모듈 내에서 함수 이름은 같은 문구, 명사, 동사를 사용한다.

## 함수 인수
- 함수에서 이상적인 인수의 개수는 0개이고 적을수록 좋다.


### 많이 쓰는 단항 형식
- 인수에 질문을 던지는 경우
- 인수를 뭔가로 변환해 결과를 반환하는 경우
- 이벤트 함수는 입력 인수만 있고 출력 인수는 없다.
- 이 경우들이 아니라면 단항 함수는 가급적 피한다.
- 출력 인수는 피한다.


### 플래그 인수
- 플래그 인수는 추하다. 함수로 부울 값을 넘기는 관례는 정말로 끔찍
- 함수가 한꺼번에 여러 가지를 처리한다고 대놓고 공표하는 셈

### 이항 함수
- 인수가 2개인 함수는 인수가 1개인 함수보다 이해하기 어렵다.
- 이항 함수가 적절한 경우
  - 직교 좌표계 점
    - 여기서 인수 2개는 한 값을 표현하는 두 요소

### 삼항 함수
- 인수가 3개인 함수는 인수가 2개인 함수보다 훨씬 더 이해하기 어렵다.

### 인수 객체
- 인수가 2~3개 필요하다면 일부를 독자적인 클래스 변수로 선언할 가능성을 짚어본다.
- 변수를 묶어 넘기려면 이름을 붙여야 하므로 결국은 개념을 표현하게 된다.

### 인수 목록
- 때로는 인수 개수가 가변적인 함수도 필요하다.
- (Object... args)를 사용하면 가변 인자를 받을 수 있다.
- 가변 인수를 취하는 모든 함수에 같은 원리가 적용된다.

### 동사와 키워드
- 함수의 의도나 인수의 순서와 의도를 제대로 표현하려면 좋은 함수 이름이 필수다.
- 단항 함수는 함수와 인수가 동사/명사 쌍을 이뤄야 한다.
  - write(name)
  - 좀 더 나은 이름 -> writeField(name)
- 함수에 키워드를 추가하는 형식
  - 함수 이름에 인수 이름을 넣는다.
    - assertEquals 보다 assertExpectedEqualsActual(expected, actual)이 더 좋다.
    - 그러면 인수 순서를 기억할 필요가 없어진다.


## 부수 효과를 일으키지 마라!
- 부수 효과는 거짓말이다. 함수에서 한 가지를 하겠다고 약속하고선 남몰래 다른 짓도 하니까
- 많은 경우 시간적인 결합과 순서 종속성을 초래한다.
- 시간적인 결합은 혼란을 일으킨다.
  - 만약 시간적인 결합이 필요하다면 함수 이름에 분명히 명시한다.


### 출력 인수
- 객체 지향 언어에서는 출력 인수를 사용할 필요가 거의 없다.
- 출력 인수로 사용하라고 설계한 변수가 바로 this

## 명령과 조회를 분리하라!
- 함수는 뭔가를 수행하거나 뭔가에 답하거나 둘 중 하나만 해야 한다.

## 오류 코드보다 예외를 사용하라!
- 명령 함수에서 오류 코드를 반환하는 방식은 명령/조회 분리 규칙을 미묘하게 위반한다.
  - 자칫하면 명령을 표현식으로 사용하기 쉬운 탓
- 오류 코드 대신 예외를 사용하면 오류 처리 코드가 원래 코드에서 분리되므로 코드가 깔끔해진다.



### Try/Catch 블록 뽑아내기 
- Try/catch 블록은 원래 추하다. 코드 구조에 혼란을 일으키며, 정상 동작과 오류 처리 동적을 뒤섞는다.
- 그러므로 try/catch 블록을 별도 함수로 뽑아내는 편이 좋다.
- 정상 동작과 오류 처리 동작을 분리하면 코드를 이해하고 수정하기 쉬워진다.


### 오류 처리도 한 가지 작업이다.
- 오류를 처리하는 함수는 오류만 처리해야 마땅하다.

## Error.java 의존성 자석
- 오류 코드를 반환한다는 이야기는, 클래스든 열거형 변수든, 어디선가 오류 코드를 정의한다는 뜻이다.
- 오류 코드 대신 예외를 사용하면 새 예외는 Exception 클래스에서 파생된다. 따라서 재컴파일/재배치 없이도 새
예외 클래스를 추가할 수 있다.

## 반복하지 마라!
- OOP는 코드를 부모 클래스로 몰아 중복을 없앤다. 구조적 프로그래밍, AOP, COP 모두 어떤 면에서 중복 제거 전략이다.


## 구조적 프로그래밍
- 입구와 출구가 하나만 존재해야 하는 원칙
- 함수를 작게 만든다면 의미가 없어진다.

## 함수를 어떻게 짜죠?
- 처음에는 길고 복잡한 코드를 짠다.
- 그런 다음 코드를 다듬고, 함수를 만들고, 이름을 바꾸고, 중복을 제거한다.
- 메서드를 줄이고 순서를 바꾼다. 떄로는 전체 클래스를 쪼개기도 한다.
- 이 와중에도 코드는 항상 단위 테스트를 통과한다.
- 최종적으로는 이 장에서 설명한 규칙을 따르는 함수가 얻어진다.

## 결론
- 이 장은 함수를 잘 만드는 기교를 소개했다. 여기서 설명한 규칙을 따른다면 길이가 짧고, 이름이 좋고, 체계가 잡힌 함수가 나오리라.
- 하지만 진짜 목표는 시스템이라는 이야기를 풀어가는 데 있다는 사실을 명심하기 바란다. 
- 여러분이 작성하는 함수가 분명하고 정확한 언어로 깔끔하게 맞아떨어져야 이야기를 풀어가기가 쉬워진다는 사실을 기억하기 바란다.


## 3장 독후감

---
함수를 되도록 짧게 만들어야 하는 이유와 그렇게 하는 방법에 대해 배웠다. 이번 장은 프리코스를 할 때 많은 도움이 될 것같다.