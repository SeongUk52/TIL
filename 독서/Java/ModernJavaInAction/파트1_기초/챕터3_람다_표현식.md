# 챕터3 람다 표현식

> #### 이 장의 내용
> - 람다란 무엇인가?
> - 어디에, 어떻게 람다를 사용하는가?
> - 실행 어라운드 패턴
> - 함수형 인터페이스, 형식 추론
> - 메서드 참조
> - 람다 만들기

## 3.1 람다란 무엇인가?
- **람다 표현식**은 메서드로 전달할 수 있는 익명 함수를 단순화한 것
  - 람다 표현식에는 이름은 없지만, 파라미터 리스트, 바디, 반환 형식, 발생할 수 있는 예외 리스트는 가질 수 있다.
    - 익명
      - 보통 메서드와 달리 이름이 없으므로 **익명**이라 표현한다. 구현해야 할 코드에 대한 걱정거리가 줄어든다.
    - 함수
      - 람다는 메서드처럼 특정 클래스에 종속되지 않으므로 함수라고 부른다. 하지만 메서드처럼 파라미터 리스트, 바디, 반환 형식,
가능한 예외 리스트를 포함한다.
    - 전달 
      - 람다 표현식을 메서드 인수로 전달하거나 변수로 저장할 수 있다.
    - 간결성
      - 익명 클래스처럼 많은 자질구레한 코드를 구현할 필요가 없다.

- 람다는 세 부분으로 이루어진다.
  - 파라미터 리스트
    - Comparator의 Compare 메서드 파라미터(사과 두 개)
  - 화살표
    - 화살표(->)는 람다의 파라미터 리스트와 바디를 구분한다.
  - 람다 바디
    - 두 사과의 무게를 비교한다. 람다의 반환값에 해당하는 표현식이다.

## 3.2 어디에, 어떻게 람다를 사용할까?
- 함수형 인터페이스라는 문맥에서 람다 표현식을 사용할 수 있다.


### 3.2.1 함수형 인터페이스
- 함수형 인터페이스: 정확히 하나의 추상 메서드를 지정하는 인터페이스
[함수형_인터페이스.md](..%2F..%2F%EC%9E%90%EB%B0%94%EB%AC%B8%EB%B2%95%2F%ED%95%A8%EC%88%98%ED%98%95_%EC%9D%B8%ED%84%B0%ED%8E%98%EC%9D%B4%EC%8A%A4.md)

> 인터페이스는 디폴트 메서드(인터페이스의 메서드를 구현하지 않은 클래스를 고려해서 기본 구현을 제공하는 바디를 포함하는 메서드)를
> 포함할 수 있다. 많은 디폴트 메서드가 있더라도 **추상 메서드가 오직 하나면** 함수형 인터페이스다.

- 람다 표현식으로 함수형 인터페이스의 추상 메서드 구현을 직접 전달할 수 있으므로 **전체 표현식을 함수형 인터페이스의 인스턴스로 취급**
  (기술적으로 따지만 함수형 인터페이스를 구현한 클래스의 인스턴스)할 수 있다.

### 3.2.2 함수 디스크럽터
- 함수형 인터페이스의 추상 메서드 시그니처(signature)는 람다 표현식의 시그니처를 가리킨다.
  - 람다 표현식의 시그니처를 서술하는 메서드를 **함수 디스크립터(function descriptor)** 라고 부른다.
- 람다 표현식은 변수에 할당하거나 함수형 인터페이스를 인수로 받는 메서드로 전달할 수 있으며, 함수형 인터페이스의 추상 메서드와 같은 시그니처를
갖는다는 사실을 기억하는 것으로 충분하다.


## 3.3 람다 활용: 실행 어라운드 패턴

## 3.4 함수형 인터페이스 사용
- 함수형 인터페이스의 추상 메서드는 람다 표현식의 시그니처를 묘사한다.
- 함수형 인터페이스의 추상 메서드 시그니처를 함수 디스크립터라고 한다.
- java.util.function 패키지는 여러 가지 새로운 함수형 인터페이스를 제공한다.

### 3.4.1 Predicate
- java.util.function.Predicate< T> 인터페이스는 test라는 추상 메서드를 정의하며 test는 제네릭 형식 T의 객체를 인수로 받아
불리언을 반환한다. 

### 3.4.2 Consumer
- java.util.function.Consumer< T> 인터페이스는 제네릭 형식 T 객체를 받아서 void를 반환하는 accept라는 추상 메서드를 정의한다.
- T형식의 객체를 인수로 받아서 어떤 동작을 수행하고 싶을 때 Consumer 인터페이스를 사용할 수 있다.

### 3.4.3 Function
- java.util.function.Function< T,R> 인터페이스는 제네릭 형식 T를 인수로 받아서 제네릭 형식 R 객체를 반환하는 추상 메서드
apply를 정의한다. 입력을 출력으로 매핑하는 람다를 정의할 때 Function 인터페이스를 활용할 수 있다.

### 기본형 특화
- 제네릭 파라미터에는 참조형만 사용할 수 있다. (Consumer< T>의 T)
- 박싱: 자바에서 제공하는 기본형을 참조형으로 변환하는 기능
  - 언박싱: 참조형을 기본형으로 변환하는 기능
    - 오토박싱: 박싱과 언박싱이 자동으로 이루어지는 기능
      - 하지만 이런 변환 과정은 비용이 소모된다. 박싱한 값은 기본형을 감싸는 래퍼며 힙에 저장된다. 따라서 박싱한 값은 메모리를
더 소비하며 기본형을 가져올 때도 메모리를 탐색하는 과정이 필요하다.

- 기본형에 특화된 함수형 인터페이스는 기본형을 입출력으로 사용하는 상황에서 오토박싱 동작을 피할 수 있게 해준다.
 
## 3.5 형식 검사, 형식 추론, 제약
- 람다 표현식 자체에는 람다가 어떤 함수형 인터페이스를 구현하는지의 정보가 포함되어 있지 않다. 따라서 람다 표현식을 더 제대로 이해하려면
람다의 실제 형식을 파악해야 한다.

### 3.5.1 형식 검사
- 람다가 사용되는 콘텍스트(context)를 이용해서 람다의 형식(type)을 추론할 수 있다.
  - 어떤 콘텍스트(예를 들면 람다가 전달될 메서드 파라미터나 람다가 할당되는 변수 등)에서 기대되는 람다 표현식의 형식을 대상 형식(target type)
이라고 부른다.
- 람다 표현식이 예외를 던질 수 있다면 추상 메서드도 같은 예외를 던질 수 있도록 throws로 선언해야 한다.

### 3.5.2 같은 람다, 다른 함수형 인터페이스
- 하나의 람다 표현식을 다양한 함수형 인터페이스에 사용할 수 있다.
- 대상 형식을 이용해서 람다 표현식을 특정 콘텍스트에 사용할 수 있다.
- 대상 형식으로 람다의 파라미터 형식도 추론할 수 있다.


### 3.5.3 형식 추론
- 자바 컴파일러는 람다 표현식이 사용된 콘텍스트(대상 형식)를 이용해서 람다 표현식과 관련된 함수형 인터페이스를 추론한다.
  - 즉, 대상 형식을 이용해서 함수 디스크립터를 알 수 있으므로 
    - 컴파일러는 람다 표현식의 파라미터 형식에 접근할 수 있으므로
      - 람다 문법에서 이를 생략할 수 있다.
        
- 상황에 따라 명시적으로 형식을 포함하는 것이 좋을 때도 있고 형식을 배제하는 것이 가독성을 향상시킬 때도 있다.


### 3.5.4 지역 변수 사용
- 람다 표현식에서는 익명 함수가 하는 것처럼 자유 변수(free variable)(파라미터로 넘겨진 변수가 아닌 외부에서 정의된 변수)를
활용할 수 있다.
  - 이와 같은 동작을 람다 캡쳐링(capturing lambda)이라고 부른다.
    - 람다에서 참고하는 지역 변수는 final로 선언되거나 실질적으로 final처럼 취급되어야 한다.

#### 지역 변수의 제약
- 인스턴스 변수는 힙에 저장
- 지역 변수는 스택에 저장

## 3.6 메서드 참조
- 메서드 참조는 특정 람다 표현식을 축약한 것
- 때로는 람다 표현식보다 메서드 참조를 사용하는 것이 더 가독성이 좋으며 자연스러울 수 있다.

### 3.6.1 요약
- 메서드 참조는 특정 메서드만을 호출하는 람다의 축약형
- 메서드 참조를 이용하면 기존 메서드 구현으로 람다 표현식을 만들 수 있다.
  - 이때 명시적으로 메서드명을 참조함으로써 가독성을 높일 수 있다.
- 메서드명 앞에 구분자(::)를 붙이는 방식으로 메서드 참조를 활용할 수 있다.
- 메서드 참조를 새로운 기능이 아니라 하나의 메서드를 참조하는 람다를 편리하게 표현할 수 있는 문법으로 간주할 수 있다.
- 메서드 참조를 이용하면 같은 기능을 더 간결하게 구현할 수 있다.

#### 메서드 참조를 만드는 방법
1. 정적 메서드 참조
   - 예를 들어 Integer의 ParseInt 메서드는 Integer::ParseInt로 표현할 수 있다.
2. 다양한 형식의 인스턴스 메서드 참조
   - 예를 들어 String의 length 메서드는 String::length로 표현할 수 있다.
3. 기존 객체의 인스턴스 메서드 참조
   - 예를 들어 Transaction 객체를 할당받은 expensiveTransaction 지역 변수가 있고, Transation 객체에는 getValue 메서드가
있다면, 이를 expensiveTransaction::getValue라고 표현할 수 있다.

- 컴파일러는 람다 표현식의 형식을 검사하던 방식과 비슷한 과정으로 메서드 참조가 주어진 함수형 인터페이스와 호환하는지 확인한다.
  - 즉, 메서드 참조는 콘텍스트 형식과 일치해야한다.

### 3.6.2 생성자 참조
ClassName::new처럼 클래스명과 new 키워드를 이용해서 기존 생성자의 참조를 만들 수 있다.


## 3.7 람다, 메서드 참조 활용하기

## 3.8 람다 표현식을 조합할 수 있는 유용한 메서드
- 자바8 API의 몇몇 함수형 인터페이스는 다양한 유틸리티 메서드를 포함
  - Comparator, Function, Predicate 같은 함수형 인터페이스는 람다 표현식을 조합할 수 있도록 유틸리티 메서드를 제공한다.
    - 여러 개의 람다 표현식을 조합해서 복잡한 람다 표현식을 만들 수 있다.
      - 여기서 등장하는 것이 바로 디폴트 메서드(추상 메서드가 아니므로 함수형 인터페이스의 정의를 벗어나지 않음)

### 3.8.1 Comparator 조합
정적 메서드 Comparator.comparing을 이용해서 비교에 사용할 키를 추출하는 Function 기반의 Comparator를 변환할 수 있다.

#### 역정렬
- 인터페이스 자체에서 주어진 비교자의 순서를 뒤바꾸는 reverse라는 디폴트 메서드가 제공됨

#### Comparator 연결
- thenComparing 메서드로 두 번째 비교자를 만들 수 있다.
  - 함수를 인수로 받아 첫 번째 비교자를 이용해서 두 객체가 같다고 판단되면 두 번째 비교자에 객체를 전달한다.

### 3.8.2 Predicate 조합
- Predicate 인터페이스는 복잡한 프레디케이트를 만들 수 있도록 negate, and, or 세 가지 메서드를 제공한다.

### 3.8.3 Function 조합
- Function 인터페이스에서 제공하는 람다 표현식도 조합할 수 있다.
  - Function 인터페이스는 Function 인스턴스를 반환하는 andThen, compose 두 가지 디폴트 메서드를 제공한다.
    - andThen 메서드는 주어진 함수를 먼저 적용한 결과를 다른 함수의 입력으로 전달하는 함수를 반환한다.
    - compose 메서드는 인수로 주어진 함수를 먼저 실행한 다음에 그 결과를 외부 함수의 인수로 제공한다.
      - andThen과 순서가 반대

## 3.9 비슷한 수학적 개념

## 3.10 마치며
- **람다 표현식**은 익명 함수의 일종이다. 이름은 없지만, 파라미터 리스트, 바디, 반환 형식을 가지며 예외를 던질 수 있다.
- 람다 표현식으로 간결한 코드를 구현할 수 있다.
- **함수형 인터페이스**는 하나의 추상 메서드만을 정의하는 인터페이스다.
- 함수형 인터페이스를 기대하는 곳에서만 람다 표현식을 사용할 수 있다.
- 람다 표현식을 이용해서 함수형 인터페이스의 추상 메서드를 즉석으로 제공할 수 있으며 
**람다 표현식 전체가 함수형 인터페이스의 인스턴스로 취급된다.**
- java.util.function 패키지는 [표 3-2]에서 소개하는 Predicate< T>, Function< T, R>,
Supplier< T>, Consumer< T>, BinaryOperator< T>등을 포함해서 자주 사용하는 다양한 함수형 인터페이스를 제공한다.
- 자바 8은 Predicate< T>와 Function< T, R> 같은 제네릭 함수형 인터페이스와 관련한 박싱 동작을 피할 수 있는
IntPredicate, IntToLongFunction 등과 같은 기본형 특화 인터페이스도 제공한다.
- 실행 어라운드 패턴(예를 들면 자원 할당, 자원 정리 등 코드 중간에 싱행해야 하는 메서드에 꼭 필요한 코드)을
람다와 활용하면 유연성과 재사용성을 추가로 얻을 수 있다.
- 람다 표현식의 기대 형식(type expected)을 대상 형식(targer type)이라고 한다.
- 메서드 참조를 이용하면 기존의 메서드 구현을 재사용하고 직접 전달할 수 있다.
- Comparator, Predicate, Function 같은 함수형 인터페이스는 람다 표현식을 조합할 수 있는 다양한 디폴트 메서드를 제공한다.

챕터 3 독후감
---
이번 챕터는 이해 안 가는 부분들이 너무 많았다. 프리코스를 미리 해보면서 함수형 인터페이스, 람다, 메서드 참조를 직접 사용해보고 감을
잡아야겠다.