# 챕터8 컬렉션 API 개선

> #### 이 장의 내용
> - 컬렉션 팩토리 사용하기
> - 리스트 및 집합과 사용할 새로운 관용 패턴 배우기
> - 맵과 사용할 새로운 관용 패턴 배우기

## 8.1 컬렉션 팩토리
- 자바 9에서는 작은 컬렉션 객체를 쉽게 만들 수 있는 몇 가지 방법을 제공한다.
- 자바 9에서 작은 리스트, 집합, 맵을 쉽게 만들 수 있도록 팩터리 메서드를 제공한다.

### 8.1.1 리스트 팩토리
- List.of 팩토리 메서드를 이용해서 간단하게 리스트를 만들 수 있다.
- 변경이 불가능함
- 데이터 처리 형식을 설정하거나 데이터를 변환할 필요가 없다면 사용하기 간편한 팩토리 메서드를 이용하는 것을 권장
  - 스트림에 비해 구현이 더 단순하고 목적을 달성하는데 충분하다.

### 8.1.2 집합 팩토리
- Set.of 

### 8.1.3 맵 팩토리
- 맵은 키와 값이 있어야 해서 리스트나 집합을 만드는 것에 비해 조금 복잡하다.
- Map.of 팩토리 메서드에 키와 값을 번갈아 제공하는 방법으로 맵을 만들 수 있다.
- 10개 이상의 키와 값을 가진 맵을 만들 때
  - Map.Entry< K, V> 객체를 인수로 받으며 가변 인수로 구현된 Map.ofEntries 팩토리 메서드를 이용하는 것이 좋다.
    - 이 메서드는 키와 값을 감쌀 추가 객체 할당을 필요로한다.
    - Map.entry는 Map.Entry 객체를 만드는 새로운 팩토리 메서드다.

## 8.2 리스트와 집합 처리
- 자바 8에서는 List.Set 인터페이스에 다음과 같은 메서드를 추가했다.
  - removeIf: 프레디케이트를 만족하는 요소를 제거한다. List나 Set을 구현하거나 그 구현을 상속받은 모든 클래스에서 이용할 수 있다.
  - replaceAll: 리스트에서 이용할 수 있는 기능으로 UnaryOperator 함수를 이용해 요소를 바꾼다.
  - sort: List 인터페이스에서 제공하는 기능으로 리스트를 정렬한다.
- 이들 메서드는 호출한 컬렉션 자체를 바꾼다.
  - 스트림 동작과 달리 이들 메서드는 기존 컬렉션을 바꾼다.


## 8.3 맵 처리

### 8.3.1 forEach 메서드
- 자바 8에서부터 Map 인터페이스는 BiConsumer (키와 값을 인수로 받음)를 인수로 받는 forEach 메서드를 지원하므로 코드를 조금 더 간단하게
구현할 수 있다.

### 8.3.2 정렬 메서드
- 다음 두 개의 새로운 유틸리티를 이용하면 맵의 항목을 값 또는 키를 기준으로 정렬할 수 있다.
  - Entry.comparingByValue
  - Entry.comparingByKey

### 8.3.3 getOrDefault 메서드
- 기존에는 찾으려는 키가 존재하지 않으면 널이 반환되므로 NullPointerException은 방지하려면 요청 결과가 널인지 확인해야 한다.
  - 기본값을 반환하는 방식으로 이 문제를 해결할 수 있다.
  - getOrDefault 메서드를 이용하면 쉽게 이 문제를 해결할 수 있다.
    - 이 메서드는 첫 번째 인수로 키를, 두 번째 인수로 기본값을 받으며 맵에 키가 존재하지 않으면 두 번째 인수로 받은 기본값을 반환한다.

### 8.3.4 계산 패턴
- 맵에 키가 존재하는지 여부에 따라 어떤 동작을 실행하고 결과를 저장해야 하는 상황이 필요한 때가 있다.
  - 예를 들어 키를 이용해 값비싼 동작을 실행해서 얻은 결과를 캐시하려 한다.
    - 키가 존재하면 결과를 다시 계산할 필요가 없다. 다음의 세 가지 연산이 이런 상황에서 도움을 준다.
      - computeIfAbsent: 제공된 키에 해당하는 값이 없으면(값이 없거나 널), 키를 이용해 새값을 계산하고 맵에 추가한다.
      - computeIfPresent: 제공된 키가 존재하면 새 값을 계산하고 맵에 추가한다.
      - compute: 제공된 키로 새 값을 계산하고 맵에 저장한다.

### 8.3.5 삭제 패턴
- 자바 8에서는 키가 특정한 값과 연관되었을 때만 항목을 제거하는 오버로드 버전 remove 메서드를 제공한다.

### 8.3.6 교체 패턴
- 멥의 항목을 바꾸는 데 사용할 수 있는 두 개의 메서드가 맵에 추가되었다.
  - replaceAll: BiFunction을 적용한 결과로 각 항목의 값을 교체한다. 이 메서드는 이전에 살펴본 List의 replaceAll과 비슷한 동작을
수행한다.
  - Replace: 키가 존재하면 맵의 값을 바꾼다. 키가 특정 값으로 매핑되었을 때만 값을 교체하는 오버로드 버전도 있다.
- 지금까지 배운 replace 패턴은 한 개의 맵에만 적용할 수 있다. 두 개의 맵에서 값을 합치거나 바꿔야 한다면 새로운
merge 메서드를 이용하면 이 문제를 해결할 수 있다.

### 8.3.7 합침
- putAll을 사용하면 두 개의 맵을 합칠 수 있다.
- 중복된 키가 없다면 위 메서드는 잘 동작한다. 값을 좀 더 유연하게 합쳐야 한다면 새로운 merge 메서드를 이용할 수 있다.
  - 이 메서드는 중복된 키를 어떻게 합칠지 결정하는 BiFunction을 인수로 받는다.
- forEach와 merge 메서드를 이용해 충돌을 해결할 수 있다. 다음 코드는 두 영화의 문자열을 합치는 방법으로 문제를 해결한다.
- merge 메서드는 널값과 관련된 복잡한 상황도 처리한다.

## 8.4 개선된 ConcurrentHashMap
- ConcurrentHashMap 클래스는 동시성 친화적이며 최신 기술을 반영한 HashMap 버전이다.
- ConcurrentHashMap은 내부 자료구조의 특정 부분만 잠궈 동시 추가, 갱신 작업을 허용한다.
- 따라서 동가화된 Hashtable 버전에 비해 읽기 쓰기 연산 성능이 월등하다. (표준 HashMap은 비동기로 동작함)

### 8.4.1 리듀스와 검색
- ConcurrentHashMap은 스트림에서 봤던 것과 비슷한 종류의 세 가지 새로운 연산을 지원한다.
  - forEach: 각(키, 값)쌍에 주어진 액션을 실행
  - reduce: 모든(키, 값)쌍을 제공된 리듀스 함수를 이용해 결과로 합침
  - search: 널이 아닌 값을 반환할 때까지 각(키, 값)쌍에 함수를 적용
- 다음처럼 키에 함수 받기, 값, Map.Entry, (키, 값) 인수를 이용한 네 가지 연산 형태를 지원한다.
  - 키, 값으로 연산(forEach, reduce, search)
  - 키로 연산(forEachKey, reduceKey, searchKeys)
  - 값으로 연산(forEachValue, reduceValues, searchValues)
  - Map.Entry 객체로 연산(forEachEntry, reduceEntries, searchEntries)
- 이들 연산은 ConcurrentHashMap의 상태를 잠그지 않고 연산을 수행한다는 점을 주목
  - 따라서 이들 연산에 제공한 함수는 계산이 진행되는 동안 바뀔 수 있는 객체, 값, 순서 등에 의존하지 않아야 한다.
- 또한 이들 연산에 병렬성 기준값(threshold)을 지정해야 한다. 맵의 크기가 주어진 기준값보다 작으면 순차적으로 연산을 실행한다.
  - 기준값을 1로 지정하면 공통 스레드 풀을 이용해 병렬성을 극대화한다.
  - Long.MAX_VALUE를 기준값으로 설정하면 한 개의 스레드로 연산을 실행한다. 
    - 여러분의 소프트웨어 아키텍처가 고급 수준의 자원 활용 최적화를 사용하고 있지 않다면 기준값 규칙을 따르는 것이 좋다.
- int, long, double 등의 기본값에는 전용 each reduce 연산이 제공되므로 reduceValuesToInt, reduceKeysToLong 등을
이용하면 박싱 작업을 할 필요가 없고 효율적으로 작업을 처리할 수 있다.

### 8.4.2 계수
- ConcurrentHashMap 클래스는 맵의 매핑 개수를 반환하는 mappingCount 메서드를 제공한다. 
- 기존의 size 메서드 대신 새 코드에서는 long을 반환하는 mappingCount 메서드를 사용하는 것이 좋다.
  - 그래야 매핑의 개수가 int의 범위를 넘어서는 이후의 상황을 대처할 수 있기 때문이다.

### 8.4.3 집합뷰
- ConcurrentHashMap 클래스는 ConcurrentHashMap을 집합 뷰로 반환하는 KeySet이라는 새 메서드를 제공한다. 맵을 바꾸면
집합도 바뀌고 반대로 집합을 바꾸면 맵도 영향을 받는다.
- newKeySet 이라는 새 메서드를 이용해 ConcurrentHashMap으로 유지되는 집합을 만들 수도 있다.

## 8.5 마치며
- 자바 9는 적은 원소를 포함하며 바꿀 수 없는 리스트, 집합, 맵을 쉽게 만들 수 있도록 List.of, Set.of, Map.of, Map.ofEntries
등의 컬렉션 팩토리를 지원한다.
- 이들 컬렉션 팩토리가 반환한 객체는 만들어진 다음 바꿀 수 없다.
- List 인터페이스는 removeIf, replaceAll, sort 세 가지 디폴트 메서드를 지원한다.
- Set 인터페이스는 removeIf 디폴트 메서드를 지원한다.
- Map 인터페이스는 자주 사용하는 패턴과 버그를 방지할 수 있도록 다양한 디폴트 메서드를 지원한다.
- concurrentHashMap은 Map에서 상속받은 새 디폴트 메서드를 지원함과 동시에 스레드 안전성도 제공한다.


## 챕터 8 독후감

---
컬렉션에서 새로 추가된 메서드들을 살펴보았고 이를 잘 익혀두면 여러 문제를 해결하는걸 더 쉽게 할 수 있을 것 같다.
