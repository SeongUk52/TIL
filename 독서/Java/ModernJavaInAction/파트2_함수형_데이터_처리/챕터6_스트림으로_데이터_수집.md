# 챕터 6 스트림으로 데이터 수집

> #### 이 장의 내용
> - Collectors 클래스로 컬렉션을 만들고 사용하기
> - 하나의 값으로 데이터 스트림 리듀스하기
> - 특별한 리듀싱 요약 연산
> - 데이터 그룹화와 분할
> - 자신만의 커스텀 컬렉터 개발

- 스트림은 데이터 집합을 멋지게 처리하는 게으른 반복자라고 설명할 수 있다.
- 다양한 요소 누적방식은 Collector 인터페이스에 정의되어 있다.

## 6.1 컬렉터란 무엇인가?
- 함수형 프로그래밍에서는 '무엇'을 원하는지 직접 명시할 수 있어서 어떤 방법으로 이를 얻을지는 신경 쓸 필요가 없다.
- 다수준으로 그룹화를 수행할 때 명령형 프로그래밍과 함수형 프로그래밍의 차이점이 더욱 두드러진다.
  - 명령형 코드에서는 문제를 해결하는 과정에서 다중 루프와 조건문을 추가하며 가독성과 유지보수성이 크게 떨어진다.
  - 함수형 프로그래밍에서는 필요한 컬렉터를 쉽게 추가할 수 있다.

### 6.1.1 고급 리듀싱 기능을 수행하는 컬렉터
- 훌륭하게 설계된 함수형 API의 또 다른 장점으로 높은 수준의 조합성과 재사용성을 꼽을 수 있다.
  - collect로 결과를 수집하는 과정을 간단하면서도 유연한 방식으로 정의할 수 있다는 점이 컬렉터의 최대 강점이다.
- 구체적으로 설명해서 스트림에 collect를 호출하면 스트림의 요소에(컬렉터로 파라미터화된) 리듀싱 연산이 수행된다.
- Collectors 유틸리티 클래스는 자주 사용하는 컬렉터 인스턴스를 손쉽게 생성할 수 있는 정적 팩토리 메서드를 제공한다.
  - 예를 들어 가장 많이 사용하는 직관적인 정적 메서드로 toList를 꼽을 수 있다.
    - toList는 스트림의 모든 요소를 리스트로 수집한다.

### 6.1.2 미리 정의된 컬렉터
Collectors에서 제공하는 메서드의 기능은 크게 세 가지로 구분할 수 있다.
- 스트림 요소를 하나의 값으로 리듀스하고 요약
- 요소 그룹화
- 요소 분할

## 6.2 리듀싱과 요약
- 컬렉터(Stream.collect 메서드의 인수)로 스트림의 항목을 컬렉션으로 재구성 할 수 있다.
  - 좀 더 일반적으로 말해 컬렉터로 스트림의 모든 항목을 하나의 결과로 합칠 수 있다.
    - 트리를 구성하는 다수준 맵, 메뉴의 칼로리 합계를 가리키는 단순한 정수 등 다양한 형식으로 결과가 도출될 수 있다.
- import static java.util.stream.Collectors.*;


### 6.2.1 스트림값에서 최댓값과 최솟값 검색
- Collectors.maxBy, Collectors.minBy 두 개의 메서드를 이용해서 스트림의 최댓값과 최솟값을 계산할 수 있다.
  - 두 컬렉터는 스트림의 요소를 비교하는 데 사용할 Comparator를 인수로 받는다. 

### 6.2.2 요약 연산
- Collecters 클래스는 Collectors.summingInt라는 특별한 요약 팩터리 메서드를 제공한다. 
  - summingInt는 객체를 int로 매핑하는 함수를 인수로 받는다.
  - summingInt의 인수로 전달된 함수는 객체를 int로 매핑한 컬렉터를 반환한다.
  - summingInt가 collect 메서드로 전달되면 요약 작업을 수행한다.
- Collectors.summingLong과 Collectors.summingDouble 메서드는 같은 방식으로 동작하며 각각 long 또는 double
형식의 데이터로 요약한다는 점만 다르다.
- 이러한 단순 합계 외에 평균값 계산 등의 연산도 요약 기능으로 제공된다. 즉, Collectors.averagingInt, averagingLong,
averagingDouble 등으로 다양한 형식으로 이루어진 숫자 집합의 평균을 계산할 수 있다.
- 종종 이들 중 두 개 이상의 연산을 한 번에 수행해야 할 때도 있다.
  - 이런 상황에서는 팩터리 메서드 summarizingInt가 반환하는 컬렉터를 사용할 수 있다.
    - IntSummaryStatistics 클래스로 모든 정보가 수집된다.
      - long, double에도 대응할 수 있다.

### 6.2.3 문자열 연결
- 컬렉터에 joining 팩토리 메서드를 이용하면 스트림의 각 객체에 toString 메서드를 호출해서 추출한 모든 문자열을 하나의
문자열로 연결해서 반환한다.
- joining 메서드는 내부적으로 StringBuilder를 이용해서 문자열을 하나로 만든다. Dish 클래스가 요리명을 반환하는 
toString 메서드를 포함하고 있다면 map으로 각 요리의 이름을 추출하는 과정을 생략할 수 있다.
- 연결될 두 요소 사이에 구분 문자열을 넣을 수 있도록 오버로드된 joining 팩토리 메서드도 있다.


### 6.2.4 범용 리듀싱 요약 연산
- 지금까지 살펴본 모든 컬렉터는 reducing 팩토리 메서드로도 정의할 수 있다. 즉, 범용 Collectors.reducing 으로도 구현할 수 있다.
- 프로그래밍적 편의성 때문에 범용 팩터리 메서드 대신 특화된 컬렉터를 사용

#### 컬렉션 프레임워크 유연성: 같은 연산도 다양한 방식으로 수행할 수 있다.

#### 자신의 상황에 맞는 최적의 해법 선택

## 6.3 그룹화
- 데이터 집합을 하나 이상의 특성으로 분류해서 그룹화하는 연산도 데이터베이스에서 많이 수행되는 작업이다.
- 명령형으로 그룹화를 구현하려면 까다롭고, 할일이 많으며, 에러도 많이 발생한다.
- 팩터리 메서드 Collectors.groupingBy를 이용해서 쉽게 그룹화할 수 있다.
- 분류 함수: 스트림을 그룹화하는데 기준이 되는 함수

### 6.3.1 그룹화된 요소 조작
- 요소를 그룹화 한 다음에는 각 결과 그룹의 요소를 조작하는 연산이 필요하다.
- filtering 메소드는 Collertors 클래스의 또 다른 정적 팩토리 메서드로 프레디케이트를 인수로 받는다.
  - 이 프레디케이트로 각 그룹의 요소와 필터링 된 요소를 재그룹화 한다.
- filtering 컬렉터와 같은 이유로 Collectors 클래스는 매핑 함수와 각 항목에 적용한 함수를 모으는 데 사용하는 또 다른 컬렉터를
인수로 받는 mapping 메서드를 제공한다.
- flatMapping 컬렉터를 이용하면 각 형식의 태그를 간편하게 추출할 수 있다.

### 6.3.2 다수준 그룹화
두 인수를 받는 팩터리 메서드 Collectors.groupingBy를 이용해서 항목을 다수준으로 그룹화할 수 있다.
- Collectors.groupingBy는 일반적인 분류 함수와 컬렉터를 인수로 받는다.
  - 즉, 바깥쪽 groupingBy 메서드에 스트림의 항목을 분류할 두 번째 기준을 정의하는 내부 groupingBy를 전달해서 두 수준으로 스트림의
항목을 그룹화할 수 있다.
- 다수준 그룹화 연산은 다양한 수준으로 확장할 수 있다.
  - 즉, n수준 그룹화의 결과는 n수준 트리 구조로 표현되는 n수준 맵이 된다.

### 6.3.3 서브그룹으로 데이터 수집

#### 컬렉터 결과를 다른 형식에 적용하기
- 팩터리 메서드 Collectors.collectingAndThen으로 컬렉터가 반환한 결과를 다른 형식으로 활용할 수 있다.
  - 팩터리 메서드 collectingAndThen은 적용할 컬렉터와 변환 함수를 인수로 받아 다른 컬렉터를 반환한다.
    - 반환되는 컬렉터는 기존 컬렉터의 래퍼 역할을 하며 collect의 마지막 과정에서 변환 함수로 자신이 반환하는 값을 매핑한다.

#### groupingBy와 함께 사용하는 다른 컬렉터 예제
- toCollection을 이용하면 원하는 방식으로 결과를 제어할 수 있다.

## 6.4 분할
- 분할은 분할 함수(partitioning function)라 불리는 프레디케이트를 분류 함수로 사용하는 특수한 그룹화 기능이다.
  - 분할 함수는 불리언을 반환하므로 맵의 키 형식은 Booleandlek.
    - 결과적으로 그룹화 맵은 최대 (참 아니면 거짓의 값을 갖는) 두 개의 그룹으로 분류된다.

### 6.4.1 분할의 장점
- 분할 함수가 반환하는 참, 거짓 두 가지 요소의 스트림 리스트를 모두 유지한다는 것이 분할의 장점이다.
- 컬렉터를 두 번째 인수로 전달할 수 있는 오버로드된 버전의 partitioningBy 메서드도 있다.
  - partitioningBy가 반환한 맵 구현은 참과 거짓 두 가지 키만 포함하므로 더 간결하고 효과적이다.
    - 사실 내부적으로도 partitioningBy는 특수한 맵과 두 개의 필드로 구현되었다.
    - 다수준으로 분할하는 기법도 있다.

### 6.4.2 숫자를 소수와 비소수로 분할하기
- 모든 컬렉터는 collector 인터페이스를 구현한다.

## 6.5 Collector 인터페이스
- Collector 인터페이스는 리듀싱 연산(즉, 컬렉터)을 어떻게 구현할지 제공하는 메서드 집합으로 구성된다.
- Collector 인터페이스의 시그니처와 다섯 개의 메서드 정의
```java
public interface Collector<T, A, R>{
  Supplier<A> supplier();
  BiConsumer<A, T> accumulator();
  Function<A, R> finisher();
  BinaryOperator<A> combiner();
  Set<Characteristics> characteristics();
```
- 위 코드를 다음처럼 설명할 수 있다.
  - T는 수집될 스트림 항목의 제네릭 형식이다.
  - A는 누적자, 즉 수집 과정에서 중간 결과를 누적하는 객체의 형식이다.
  - R은 수집 연산 결과 객체의 형식(항상 그런 것은 아니지만 대게 컬렉션 형식)이다.
- 누적 과정에서 사용되는 객체가 수집 과정의 최종 결과로 사용된다.

### 6.5.1 Collector 인터페이스의 메서드 살펴보기

#### supplier 메서드: 새로운 결과 컨테이너 만들기
- supplier 메서드는 빈 결과로 이루어진 Supplier를 반환해야 한다. 즉, supplier는 수집 과정에서 빈 누적자 인스턴스를 만드는
파라미터가 없는 함수다.

#### accumulator 메서드: 결과 컨테이너에 요소 추가하기
- accumulator 메서드는 리듀싱 연산을 수행하는 함수를 반환한다.
  - 스트림에서 n번째 요소를 탐색할 때 두 인수,
    - 즉 누적자(스트림의 첫 n-1개 항목을 수집한 상태)와 n번째 요소를 함수에 적용한다.
      - 함수의 반환값은 void
        - 즉 요소를 탐색하면서 적용하는 함수에 의해 누적자 내부상태가 바뀌므로 누적자가 어떤 값일지 단정할 수 없다.

#### finisher 메서드: 최종 변환값을 결과 컨테이너로 적용하기
- finisher 메서드는 스트림 탐색을 끝내고 누적자 객체를 최종 결과로 변환하면서 누적 과정을 끝낼 때 호출할 함수를 반환해야 한다.

#### combiner 메서드: 두 결과 컨테이너 병합
- combiner는 스트림의 서로 다른 서브파트를 병렬로 처리할 때 누적자가 이 결과를 어떻게 처리할지 정의한다.

#### characteristics 메서드
- characteristics 메서드는 컬렉터의 연산을 정의하는 Characteristics 형식의 불변 집합을 반환한다.
  - Characteristics는 스트림을 병렬로 리듀스할 것인지 그리고 병렬로 리듀스한다면 어떤 최적화를 선택해야 할지 힌트를 제공한다.
  - Characteristics는 다음 세 항목을 포함하는 열거형이다.
    - UNORDERED: 리듀싱 결과는 스트림 요소릐 방문 순서나 누적 순서에 영향을 받지 않는다.
    - CONCURRENT: 다중 스레드에서 accumulator 함수를 동시에 호출할 수 있으며 이 컬렉터는 스트림의 병렬 리듀싱을 수행할 수 있다.
컬렉터의 플래그에 UNORDERED를 함께 설정하지 않았다면 데이터 소스가 정렬되어 있지 않은(즉, 집합처럼 요소의 순서가 무의미 한) 상황에서만
리듀싱을 수행할 수 있다.
    - IDENTITY_FINISH: finisher 메서드가 반환하는 함수는 단순히 identity를 적용할 뿐 이므로 이를 생략할 수 있다.
따라서 리듀싱 과정의 최정 결과로 누적자 객체를 바로 사용할 수 있다. 또한 누적자 A를 결과 R로 안전하게 형변환할 수 있다.


## 6.6 커스텀 컬렉터를 구현해서 성능 개선하기

## 6.7 마치며
- collect는 스트림의 요소를 요약 결과로 누적하는 다양한 방법(컬렉터라 불리는)을 인수로 갖는 최종 연산이다.
- 스트림의 요소를 하나의 값으로 리듀스하고 요약하는 컬렉터뿐 아니라 최솟값, 최댓값, 평균값을 계산하는 컬렉터 등이 미리 정의되어 있다.
- 미리 정의된 컬렉터임 groupingBy로 스트림의 요소를 그룹화하거나, partitioningBy로 스트림의 요소를 분할할 수 있다.
- 컬렉터는 다수준의 그룹화, 분할, 리듀싱 연산에 적합하게 설계되어 있다.
- Collector 인터페이스에 정의된 메서드를 구현해서 커스텀 컬렉터를 개발할 수 있다.

## 챕터6 독후감

---
생각한 것 보다도 외워야 할 것이 너무 많고 이해가 안 가는 부분도 많았다. 강의나 인터넷 검색 등으로 따로 보충해서 공부하는게 좋을 것 같다.
